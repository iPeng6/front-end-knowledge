# Diff 算法

## O(n3)

传统树的更新需要O(n3)，即便三次方效率也经过了30年的改进，所以细节上个人能力还是有限，直观上感受下就好。

一颗树更新成另一颗树，为什么需要这么麻烦？直接创建一颗新的树不就完了（我咋想到了项目重构还不如重做）？主要考虑点还是**复用**。

这里面权衡的就是 复用成本 和 创建成本。在dom操作时，创建成本远高于更新移动。

假设每一个节点对应现实中的一座金字塔，一棵树对应着地图上所有金字塔的排列，国王现在想在这棵树中间插入一座新的金字塔，工程师会怎么做？

把所以金字塔铲平，重洗按照新的树再建一遍？当然不行，工程师这时要考虑的就是diff算法，以最小的成本更新原有的树。

为什么是三次方？

首先假设一棵树，节点完全打乱变成另一棵树，这时要更新的话，就得两两比较，这时就得O(n2)，类似选择排序，遍历一棵树的时候就得去另一棵树里找到对应的过来更新。如果没找到还得删除，还有一种情况就是新树里面还多出来一些节点，就得找到位置插入。

但是一棵树的插入删除是复杂的，算法里有个编辑距离（Tree edit distance）的概念。直观的感受是什么，比如一个数组，想要在中间插入一个数字，是不是得把后面的所有数字都得挪动一遍，平均就是O(n)的复杂度，所以传统的复杂度就是O(n3)

## O(n)

react 中的策略

1. 同级⽐较，WebUI中DOM节点跨层级的移动操作特别少，可以忽略不计。
2. 拥有不同类型的两个组件将会⽣生成不同的树形结构。
3. 开发者可以通过key prop 来暗示哪些⼦元素在不同的渲染下能保持稳定;

这样只需要一次遍历O(n)
